{"version":3,"file":"type-into.js","sourceRoot":"","sources":["../../src/actions/type-into.ts"],"names":[],"mappings":";;;;AAAA,wCAA2C;AAC3C,wCASmB;AAOnB,iDAA4C;AAE5C;;;;;;;GAOG;AACI,MAAM,QAAQ,GAAG,CACtB,OAAsB,EACtB,IAAY,EACZ,SAA0B,EAAE,EACD,EAAE;IAC7B,uCAAuC;IACvC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,wBAAc,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;IAEzD,uCAAuC;IACvC,MAAM,KAAK,GAAqB,IAAI,eAAK,EAAE,CAAC,KAAK,EAAE,CAAA;IAEnD,8CAA8C;IAC9C,MAAM,KAAK,GAAa,CAAC,GAAG,IAAI,CAAC,CAAA;IAEjC,qCAAqC;IACrC,2EAA2E;IAC3E,MAAM,OAAO,CAAC,KAAK,EAAE,CAAA;IACrB,MAAM,IAAA,wBAAc,EAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAA;IAC5C,MAAM,OAAO,CAAC,KAAK,CAAC,EAAE,KAAK,EAAE,IAAA,cAAI,EAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAA;IACzD,MAAM,IAAA,wBAAc,EAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAA;IAE5C,mCAAmC;IACnC,IAAI,QAAQ,GAAW,CAAC,CAAA;IACxB,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,QAAQ,GAA8B,IAAA,wBAAc,EAAC,IAAI,CAAC,CAAA;QAChE,2CAA2C;QAC3C,IAAI,QAAQ,KAAK,aAAa,EAAE;YAC9B,MAAM,IAAA,0BAAW,EAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAA;SAC3C;QAED,qCAAqC;QACrC,IAAI,QAAQ,KAAK,aAAa,EAAE;YAC9B,MAAM,IAAA,wBAAc,EAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAA;SAC5C;QAED,sDAAsD;QACtD,4CAA4C;QAC5C,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAA,uBAAa,GAAE,CAAC,CAAA;QACzC,MAAM,IAAA,wBAAc,EAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAEhC,8DAA8D;QAC9D,IACE,QAAQ;YACR,CAAC,QAAQ,KAAK,aAAa,IAAI,QAAQ,KAAK,aAAa,CAAC;YAC1D,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,EACtC;YACA,MAAM,IAAA,wBAAc,EAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAA;SACvC;QAED,iDAAiD;QACjD,IAAI,IAAA,mBAAS,EAAC,QAAQ,CAAC,IAAI,IAAA,gBAAM,EAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACxD,MAAM,IAAA,wBAAc,EAAC,MAAM,CAAC,OAAO,CAAC,CAAA;SACrC;QAED,0CAA0C;QAC1C,QAAQ,EAAE,CAAA;KACX;IAED,wCAAwC;IACxC,MAAM,IAAA,wBAAc,EAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;IAErC,qCAAqC;IACrC,KAAK,CAAC,IAAI,EAAE,CAAA;IAEZ,IAAA,eAAK,EAAC,UAAU,IAAI,UAAU,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAA;IACpD,OAAO,KAAK,CAAA;AACd,CAAC,CAAA,CAAA;AAlEY,QAAA,QAAQ,YAkEpB","sourcesContent":["import { TypeIntoSchema } from \"../schemas\"\nimport {\n  chance,\n  debug,\n  detectCharType,\n  isCadence,\n  keypressDelay,\n  rand,\n  Timer,\n  waitForTimeout\n} from \"../support\"\nimport {\n  CharacterType,\n  ElementHandle,\n  PerformanceTimer,\n  TypeIntoOptions\n} from \"../types\"\nimport { typeMistake } from \"./type-mistake\"\n\n/**\n * Humanizes text input into a specified element.\n *\n * @param {ElementHandle} element\n * @param {string} text\n * @param {TypeIntoOptions} config\n * @return {Promise<PerformanceTimer>}\n */\nexport const typeInto = async (\n  element: ElementHandle,\n  text: string,\n  config: TypeIntoOptions = {}\n): Promise<PerformanceTimer> => {\n  // Validate config and inject defaults.\n  const { delays, mistakes } = TypeIntoSchema.parse(config)\n\n  // Start performance timer for logging.\n  const timer: PerformanceTimer = new Timer().start()\n\n  // Break input string into individual letters.\n  const chars: string[] = [...text]\n\n  // Click element to allow text input.\n  // TODO: Add mouse lib to avoid clicking in the dead center of the element.\n  await element.hover()\n  await waitForTimeout({ min: 100, max: 200 })\n  await element.click({ delay: rand({ min: 5, max: 15 }) })\n  await waitForTimeout({ min: 200, max: 800 })\n\n  // Type each character in sequence.\n  let position: number = 0\n  for (const char of chars) {\n    const charType: CharacterType | undefined = detectCharType(char)\n    // Add potential for mistakes while typing.\n    if (charType !== \"termination\") {\n      await typeMistake(element, char, mistakes)\n    }\n\n    // Delay slightly before punctuation.\n    if (charType === \"punctuation\") {\n      await waitForTimeout({ min: 50, max: 100 })\n    }\n\n    // Type the correct character and add post type delay.\n    // TODO: Make capital letters use shift key.\n    await element.type(char, keypressDelay())\n    await waitForTimeout(delays.all)\n\n    // Add longer delay after sentence termination or punctuation.\n    if (\n      charType &&\n      (charType === \"punctuation\" || charType === \"termination\") &&\n      Object.keys(delays).includes(charType)\n    ) {\n      await waitForTimeout(delays[charType])\n    }\n\n    // Vary longer delays on natural typing cadences.\n    if (isCadence(position) && chance(delays.cadence.chance)) {\n      await waitForTimeout(delays.cadence)\n    }\n\n    // Increment counter for cadence tracking.\n    position++\n  }\n\n  // Pause a moment after finishing input.\n  await waitForTimeout(delays.complete)\n\n  // Stop and return performance timer.\n  timer.stop()\n\n  debug(`Typed \"${text}\" over ${timer.duration()}ms.`)\n  return timer\n}\n"]}